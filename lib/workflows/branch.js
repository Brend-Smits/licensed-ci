const core = require('@actions/core');
const exec = require('@actions/exec');
const github = require('@actions/github');
const utils = require('../utils');

const PULL_REQUEST_TEMPLATE = `
This PR was auto generated by the \`licensed-ci\` GitHub Action.
It contains updates to cached \`github/licensed\` dependency metadata to be merged into \`<base>\`: (<links>).

The \`licensed-ci\` action will add comments to this PR with the status of license checks.  Please make any changes needed to fix any status failures on this branch, then merge license updates into your branch.

If updates are unexpected, please check the \`github/licensed\` [changelog](https://github.com/github/licensed/tree/master/CHANGELOG.md) for recent updates.
`.trim();

// Create a pull request for the licenses branch
async function createLicensesPullRequest(octokit, head, base, userPullRequest) {
  const actor = process.env.GITHUB_ACTOR;
  let links = `[branch](https://github.com/${github.context.repo.owner}/${github.context.repo.repo}/tree/${base})`;
  if (userPullRequest) {
    links = `${links}, [PR](${userPullRequest.html_url})`
  }

  const body = PULL_REQUEST_TEMPLATE.replace('<base>', base)
                                    .replace('<links>', links);

  const { data: pull } = await octokit.rest.pulls.create({
    ...github.context.repo,
    title: `License updates for ${base}`,
    head,
    base,
    body
  });

  try {
    // this will fail if the PR is created using a PAT 
    // from `actor`s user account
    await octokit.rest.pulls.requestReviewers({
      ...github.context.repo,
      pull_number: pull.number,
      reviewers: [actor]
    });
  } catch (e) {
    core.warning(e.message)
  }  

  core.info(`Created pull request for changes: ${pull.html_url}`);
  return pull;
}

const NOTIFY_STATUS_TEMPLATE = `
The \`licensed-ci\` GitHub Action updated cached license metadata based on changes to \`<base>\`: (<links>).

**\`licensed status\` result: <status>**
<statusMessage>

\`\`\`
<log>
\`\`\`

<prComment>

/cc @<actor>
`.trim();

const STATUS = {
  true: "SUCCEEDED",
  false: "FAILED"
};

const STATUS_MESSAGES = {
  true: 'All status checks succeeded, please merge when ready.',
  false: 'There are reported status failures, please fix all logged errors before merging.'
};

// Create a comment on the licenses PR giving an update on the latest status
async function notifyStatus(octokit, userBranch, userPullRequest, licensesPullRequest, statusResult) {
  const actor = process.env.GITHUB_ACTOR;
  const prComment = core.getInput('pr_comment');
  if (prComment) {
    core.warning('"pr_comment" is deprecated.  Please use the "pr_url" and "pr_number" step outputs to script additional actions on the created pull request.');
  }

  let links = `[branch](https://github.com/${github.context.repo.owner}/${github.context.repo.repo}/tree/${userBranch})`;
  if (userPullRequest) {
    links = `${links}, [PR](${userPullRequest.html_url})`
  }

  const body = NOTIFY_STATUS_TEMPLATE.replace('<prComment>', prComment)
                                     .replace('<status>', STATUS[statusResult.success])
                                     .replace('<statusMessage>', STATUS_MESSAGES[statusResult.success])
                                     .replace('<log>', statusResult.log)
                                     .replace('<actor>', actor)
                                     .replace('<base>', userBranch)
                                     .replace('<links>', links);

  await octokit.rest.issues.createComment({
   ...github.context.repo,
   issue_number: licensesPullRequest.number,
   body,
  });
}

const NOTIFY_USER_TEMPLATE = `
The \`licensed-ci\` GitHub Action has <action> a [pull request](<pr url>) containing license metadata updates based on the changes in this branch.

Please review the pull request for any additional changes required and merge when ready.
`.trim();

const ACTIONS = {
  true: 'created',
  false: 'updated'
};

// Create a comment on the user's PR notifying that updates were made to the
// licenses branch/PR
async function notifyUser(octokit, userPullRequest, licensesPullRequest, created) {
  const body = NOTIFY_USER_TEMPLATE.replace('<pr url>', licensesPullRequest.html_url)
                                   .replace('<action>', ACTIONS[created]);

  await octokit.rest.issues.createComment({
   ...github.context.repo,
   issue_number: userPullRequest.number,
   body,
  });
}

function getLicensesBranches(branch) {
  if (branch.endsWith('-licenses')) {
    return [branch, branch.replace(/-licenses$/, '')];
  }

  return [`${branch}-licenses`, branch];
}

async function run() {
  let licensesUpdated = false;
  let pullRequestCreated = false;

  const branch = utils.getBranch(github.context);
  const [licensesBranch, userBranch] = getLicensesBranches(branch);
  core.setOutput('licenses_branch', licensesBranch);
  core.setOutput('user_branch', userBranch);

  // // find an existing pull request, if one exists
  const token = core.getInput('github_token', { required: true });
  const octokit = github.getOctokit(token);
  let licensesPullRequest = await utils.findPullRequest(octokit, { head: licensesBranch, base: userBranch });

  const { command, configFilePath } = await utils.getLicensedInput();

  // check whether cached metadata needs any updating
  let statusResult = await utils.checkStatus(command, configFilePath);
  if (statusResult.success) {
    if (branch !== licensesBranch && core.getInput('cleanup_on_success', { required: true }) === 'true') {
      // delete the licenses branch if it exists
      // the action doesn't deal well with reusing previous branches
      core.info('License checks succeeded. Cleaning up branches and PRs');
      await utils.closePullRequest(octokit, licensesPullRequest);
      await utils.deleteBranch(licensesBranch);
    }

    return;
  }

  // recache data only when on a non-licenses branch
  if (branch !== licensesBranch) {
    // change to a `<branch>-licenses` branch to continue updates
    const [localLicensesBranch, localUserBranch] = await utils.ensureBranch(licensesBranch, userBranch);

    // ensure that branch is up to date with parent
    let exitCode = await exec.exec('git', [...utils.userConfig(), 'merge', '-s', 'recursive', '-Xtheirs', localUserBranch], { ignoreReturnCode: true });
    if (exitCode !== 0) {
      throw new Error(`Unable to get ${licensesBranch} up to date with ${userBranch}`);
    }

    // cache any metadata updates
    await exec.exec(command, ['cache', '-c', configFilePath]);

    // stage any changes, checking only configured cache paths if possible
    const cachePaths = await utils.getCachePaths(command, configFilePath);
    await exec.exec('git', ['add', '--', ...(await utils.filterCachePaths(cachePaths))]);

    // check for any changes, checking only configured cache paths if possible
    exitCode = await exec.exec('git', ['diff-index', '--quiet', 'HEAD', '--', ...cachePaths], { ignoreReturnCode: true });
    if (exitCode > 0) {
      // if files were changed, push them back up to origin using the passed in github token
      await exec.exec('git', [...utils.userConfig(), 'commit', '-m', utils.getCommitMessage()]);

      const extraHeadersConfig = await utils.extraHeaderConfigWithoutAuthorization();
      await exec.exec('git', [...extraHeadersConfig, 'push', utils.getOrigin(), `${localLicensesBranch}:${licensesBranch}`]);
      licensesUpdated = true;

      const userPullRequest = await utils.findPullRequest(octokit, { head: userBranch, "-base": userBranch });
      if (!licensesPullRequest) {
        licensesPullRequest = await createLicensesPullRequest(octokit, licensesBranch, userBranch, userPullRequest);
        pullRequestCreated = true;
      }

      statusResult = await utils.checkStatus(command, configFilePath);
      await notifyStatus(octokit, userBranch, userPullRequest, licensesPullRequest, statusResult);

      if (userPullRequest) {
        await notifyUser(octokit, userPullRequest, licensesPullRequest, pullRequestCreated);
      }
    }

    await exec.exec('git', ['checkout', branch]);
  }

  core.setOutput('licenses_updated', licensesUpdated.toString());

  // set the PR url and number to output if one exists
  if (licensesPullRequest) {
    core.setOutput('pr_url', licensesPullRequest.html_url);
    core.setOutput('pr_number', licensesPullRequest.number);
    core.setOutput('pr_created', pullRequestCreated.toString());
  }

  // fail if initial check didn't succeed
  throw new Error('Cached metadata checks failed');
}

module.exports = { run };
